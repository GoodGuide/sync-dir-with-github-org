#!/usr/bin/env ruby

require 'pathname'
require 'optparse'

file = File.symlink?(__FILE__) ? File.readlink(__FILE__) : __FILE__
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', file)
require 'bundler/setup'
require 'octokit'
require 'pry'
require 'concurrent'

ROOT_PATH = Pathname.new(Dir.getwd)

def system(command)
  STDERR.puts "  > #{command}"
  Kernel.system command
end

def prompt(ask)
  STDERR.print(ask << ' ')
  STDIN.gets.chomp.downcase[0] == 'y'
end

def fixit(desc, expected, actual, should_correct=nil, &correction)
  return if expected == actual

  warn "#{desc} is incorrect:"
  warn "  expected: #{expected}"
  warn "  got:      #{actual}"

  should_correct = prompt('Fix it?') if should_correct.nil?
  correction.call if should_correct
end


def options
  @options ||= {}
end

def opt_parser
  @opt_parser ||= OptionParser.new { |opts|
    opts.banner = "Usage: #{$0} [options]"

    opts.on("-f", "--[no-]fix-remotes", "Always fix git remotes URLs; default is to prompt.") do |v|
      options[:always_fix_remotes] = v
    end

    opts.on("-C", "--[no-]clone-missing", "Always clone missing repos including forks; default is to prompt") do |v|
      options[:always_clone_missing] = v
    end

    opts.on("--ignore-legacy-repos", "Ignore repos with a name starting with 'legacy-'") do |v|
      options[:ignore_legacy] = v
    end
  }
end

def run_async
  options_which_inhibit_prompting = [:always_clone_missing, :always_fix_remotes]
  (options_which_inhibit_prompting & options.keys) == options_which_inhibit_prompting
end

opt_parser.parse!

puts 'SHOULD RUN ASYNC' if run_async

client = Octokit::Client.new(access_token: ENV.fetch('GITHUB_TOKEN'))
client.auto_paginate = true

org_name = ARGV[0] || ROOT_PATH.basename.to_s

STDERR.print "Fetching all '#{org_name}' repos... "
org_repos = client.org_repos(org_name).sort_by(&:full_name)
warn "Got #{org_repos.count} repos"

repo_directories = []

def capture(*args)
  opts = args.pop if args.last.is_a?(Hash)
  r, w = IO.pipe
  p args, opts
  pid = Process.spawn(*args, opts.merge(out: w))
  _, pstat = Process.wait2(pid)
  pstat.success? or raise "Execution failed for #{args}"
  w.close
  r.read
ensure
  w.close unless w.closed?
  r.close unless r.closed?
end

def run(*args)
  p args
  pid = Process.spawn(*args)
  _, pstat = Process.wait2(pid)
  pstat.success? or raise "Execution failed for #{args}"
end

promises = org_repos.map do |repo|
  warn "- #{repo.full_name}"

  just_cloned = false

  directory = ROOT_PATH.join(repo.name)

  # track for later
  repo_directories << directory

  if repo.name.start_with?('legacy-') and options[:ignore_legacy]
    warn "Skipping legacy repo"
    next
  end

  run_opts = { chdir: directory.to_s }

  Concurrent::Promise.new(executor: Concurrent.configuration.global_task_pool) do
    print "Starting for #{directory}\n"
    if directory.directory?
      current_url = capture('git', 'config', 'remote.origin.url', run_opts).chomp
      fixit('Current remote URL', repo.ssh_url, current_url, options[:always_fix_remotes]) do
        run(*%W[git config remote.origin.url #{repo.ssh_url}], run_opts)
      end

      run(*%w[git fetch origin --prune --tags --recurse-submodules=yes], run_opts)
      run(*%w[git submodule init], run_opts)

    else
      if repo.fork
        should_clone = options.fetch(:always_clone_missing) {
          prompt("Repo is a fork and isn't yet cloned at ./#{directory}; clone anyway?")
        }
        next unless should_clone
      end

      run(*%W[git clone --recursive #{repo.ssh_url} ./#{repo.name}], run_opts)
      just_cloned = true
    end

    if repo.fork
      # warn "fetching more detail..."
      # replace with full object via /repos/:name
      repo = client.repo(repo.full_name)

      current_upstream_url = capture('git', 'config', 'remote.upstream.url', run_opts).chomp
      current_upstream_url = nil unless $?.success?
      fixit('Upstream remote URL', repo.parent.ssh_url, current_upstream_url, just_cloned || options[:always_fix_remotes]) do
        if current_upstream_url.nil?
          run(%W[git remote add upstream #{repo.parent.ssh_url}], run_opts)
        else
          run(%W[git remote set-url upstream #{repo.parent.ssh_url}], run_opts)
        end

        current_upstream_url = repo.parent.ssh_url

        run(*%w[git fetch upstream --prune --tags --recurse-submodules=yes], run_opts) unless current_upstream_url.nil?
      end
    end

    hooksdir = directory.join('.git', 'hooks')
    if hooksdir.symlink?
      hooksdir.delete
    end
    run('goodguide-git-hooks', 'install', '--noclobber', chdir: directory.to_s)
    print "Finished for #{directory}\n"
  end
end

promises.compact!

if run_async
  promises.each(&:execute)
else
  promises.reduce(Concurrent::Promise.fulfill(true)) do |prev, this|
    prev.then do
      this.execute
    end
    this
  end
end

Concurrent::Promise.all?(promises).wait.rescue do
  promises.each do |promise|
    next unless promise.rejected?
    p promise.reason
  end
end

dirs = []
ROOT_PATH.each_child do |e|
  next unless e.directory?
  dirs << e
end

untracked_dirs = dirs - repo_directories

if untracked_dirs.count > 0
  puts "There are %i untracked directories in the tree:" % untracked_dirs.count
  puts untracked_dirs
end
